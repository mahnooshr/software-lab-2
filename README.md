# software-lab-2

# مشکلات کد (Bad smell)

1- تخطی از DIP: تابع سطح بالای `PaymentProcessor` مستقیما به پیاده سازی های سطح پایین مثل `processCreditCard` یا `processDigitalWallet` وابسته است.

2- کد غیر منعطف: اگر روش پرداخت جدیدی اضافه شود، نیاز به تغییر `PaymentProcessor` خواهد بود. استفاده از `switch-case` نشان دهنده وابستگی شدید می باشد.

3- بیش از حد بزرگ بودن و مسئولیت چندگانه داشتن : کلاس `PaymentProcessor` چندین کار از قبیل اعتبار سنجی، پرداخت و لاگ گیری را درون خود دارد.

4- وجود متد ها با پارامتر های ورودی زیاد: وجود پارامتر های زیاد ورودی باعث می شود خوانایی کد پایین بیاید و نگهداری از آن دشوار می شود. می توان از یک شی مانند `PaymentRequest` برای مختصر کردن ورودی ها استفاده کرد.

5- وجود کد های تکراری: بخش های زیادی از توابع `processCreditCard`, `processDigitalWallet` و `processBankTransfer` دارای مشابهت می باشند.

6- استفاده نکردن از مکانیزم های کنترل `exception`: در توابعی که از `API` های خارجی استفاده می کنند، در صورتی که سرویس مورد نظر به هر دلیلی پاسخ مورد نظر را ندهد یا به مشکل بخورد، استفاده از مکانیزمی مانند `try-catch` می تواند کمک کننده باشد.




# بررسی اصول SOLID

1- اصل `SRP (single responsibility principle)`:

پردازش های مربوط به حالات متفاوت
payment
همگی در کلاس
PaymentProcessor
انجام میشود که در تعارض با این اصل است. می توان به ازای هر کدام از حالات یک کلاس جداگانه داشت
و عملیات های مربوط در آن ها انجام شوند.
همچنان عملیات 
validation 
باید در کلاسی جداگانه اتفاق بیافتد تا کلاس اصلی به کار های متفاوتی نپردازد.

2- اصل `OCP (open-closed principle)`:

از آن جایی که همواره
switch case
در تعارض با 
open-closed
است و در صورت اضافه شدن حالت به حالات پرداخت مجبوریم این کلاس را تغییر دهیم می توانیم به جای
switch case
از 
polymorphism
استفاده کنیم.
برای این کار باید به ازای هر حالت یک کلاس جداگانه ایجاد کنیم و به جای آن که
switch case
را در کلاس اصلی  بگذاریم در جایی دیگر مانند
factory
قرار دهیم. همچنان به جای 
switch case
در
factory
می توانیم از یک 
Map
استفاده کنیم که هر حالت پرداخت را به پیاده سازی مربوط وصل می کند.
در آن صورت کلاس فعلی تغییر نخواهد کرد و اصل
open closed
برای آن اعمال میشود.

همچنان نکته دیگری که وجود دارد مربوط به 
logging
است.
در حالت فعلی در جا های مختلف کد اطلاعات در کنسول 
print 
شده اند. لیکن اگر بخواهیم به جای کنسول در فایل بنویسیم باید تغییرات زیادی بدهیم
و در تعارض با این اصل است.
برای جلوگیری از این مورد می توان عملیات
logging
را به یک 
interface
ورودی بدهیم و این مسئولیت را در جای دیگری مدیریت کنیم.


3- اصل `LSP (liskov substitution principle)`: اصل `LSP` بیان می‌کند که اشیای یک کلاس فرزند باید بتوانند بدون ایجاد تغییر در رفتار، جایگزین کلاس والد خود شوند. در کد فعلی، `PaymentProcessor` به‌طور مستقیم وابسته به متدهای خاصی برای پردازش هر نوع پرداخت (`processCreditCard`, `processDigitalWallet`, `processBankTransfer`) است. این مسئله باعث می‌شود که اگر بخواهیم یک روش پرداخت جدید (مثلاً پرداخت از طریق رمزارز) اضافه کنیم، مجبور باشیم کد `processPayment` را تغییر دهیم. این نقض اصل LSP است، زیرا امکان جایگزینی و گسترش کلاس‌ها بدون تغییر در رفتار کلاس والد وجود ندارد.

برای اصلاح این مشکل، باید یک رابط مشترک (`PaymentMethod`) برای تمامی روش‌های پرداخت ایجاد کنیم. سپس هر روش پرداخت (مانند `CreditCardPayment`, `DigitalWalletPayment`, `BankTransferPayment`) از این اینترفیس پیروی کند و متد مربوط به پردازش پرداخت را درون خود پیاده‌سازی کند. در این حالت، `PaymentProcessor` به جای استفاده از `switch-case` برای تشخیص نوع پرداخت، فقط یک نمونه از `PaymentMethod` را دریافت کرده و متد پردازش را فراخوانی می‌کند. این تغییر باعث می‌شود که افزودن روش‌های جدید پرداخت، بدون تغییر در `PaymentProcessor` امکان‌پذیر شود و اصل `LSP` رعایت گردد.

4- اصل `ISP (interface segregation principle)`: اصل `ISP` بیان می‌کند که اینترفیس‌ها باید کوچک و تخصصی باشند، به‌طوری‌که پیاده‌سازی‌کنندگان مجبور به استفاده از متدهایی که نیاز ندارند، نشوند. در کد فعلی، کلاس `PaymentProcessor` چندین وظیفه مختلف را انجام می‌دهد: اعتبارسنجی پرداخت، پردازش پرداخت و ثبت گزارش تراکنش‌ها. این امر باعث می‌شود که اگر در آینده تغییری در یکی از این بخش‌ها لازم باشد، کل کلاس تحت تأثیر قرار بگیرد. همچنین، ممکن است برخی از پیاده‌سازی‌های آینده نیازی به بعضی از این متدها نداشته باشند، اما به‌ناچار مجبور به استفاده از آن‌ها شوند، که این نقض اصل ISP است.

برای برطرف کردن این مشکل، باید دو اینترفیس مستقل ایجاد کنیم: یکی برای اعتبارسنجی پرداخت `(PaymentValidator)` و دیگری برای پردازش پرداخت `(PaymentHandler)`. این کار باعث می‌شود که کلاس‌هایی که فقط به وظیفه خاصی نیاز دارند، فقط اینترفیس مربوطه را پیاده‌سازی کنند. مثلاً، اگر در آینده ماژول جدیدی برای پردازش پرداخت اضافه شود، نیازی به درگیر شدن با متدهای اعتبارسنجی نخواهد داشت. این تغییر علاوه بر افزایش انعطاف‌پذیری، باعث می‌شود که کلاس‌های مختلف فقط مسئولیت‌های مشخص خود را بر عهده بگیرند، که در نهایت منجر به کدی تمیزتر و قابل نگهداری‌تر خواهد شد.


5- اصل `DIP (dependency inversion principle)`: در کد داده شده، به دلیل وابستگی `PaymentProcessor` به توابع سطح پایین تری مانند `processCreditCard،` `processBandTransfer` و `processDigitalWallet` اصل `DIP` نقض شده و می تواند مشکل ساز شود. برای رفع این موضوع می توان از یک `interface` مانند `PaymentService` استفاده کرد و هر کدام از روش های از این رابط استفاده کنند و صرفا `PaymentProcessor` از این `interface` برای انجام کار ها استفاده کند.



هدف: پیاده سازی یک سیستم پردازش آنلاین پرداخت با مقیاس و اصول پیاده سازی شی گرا در چهار مرحله 

# فاز ۲: بازآرایی و انتزاع

در فاز دوم پروژه، کد به منظور بهبود ساختار و رعایت اصول طراحی شیءگرای SOLID بازآرایی شد. هدف اصلی این فاز معرفی انتزاع و کپسوله‌ سازی منطق پردازش پرداخت‌ ها بود. در این مرحله، کلاس‌ های خاص برای هر نوع پرداخت (کارت اعتباری، کیف پول دیجیتال، و انتقال بانکی) ایجاد شده‌ اند.

## تغییرات اعمال شده
### ۱. ایجاد کلاس انتزاعی Payment:

کلاس Payment به عنوان یک کلاس انتزاعی برای تمام انواع پرداخت‌ ها طراحی شده است. این کلاس ویژگی‌ های مشترک مانند `amount`, `currency`, `customerInfo`, و `paymentDetails` را تعریف می‌ کند. همچنین متد های انتزاعی `()validatePayment` و `()processPayment` را برای پیاده‌سازی در کلاس‌های زیرمجموعه تعیین کرده است.

### ۲. ایجاد زیرکلاس‌ها برای هر نوع پرداخت:

سه کلاس زیرمجموعه برای انواع مختلف پرداخت‌ ها ایجاد شدند:

`CreditCardPayment`: برای پردازش پرداخت‌های با کارت اعتباری

`DigitalWalletPayment`: برای پردازش پرداخت‌های با کیف پول دیجیتال

`BankTransferPayment`: برای پردازش پرداخت‌های با انتقال بانکی




هر کدام از این کلاس‌ ها متد های `()validatePayment` و `()processPayment` را به‌ طور خاص خود پیاده‌ سازی کرده‌ اند.

### معرفی زیرکلاس `CreditCardPayment`:

این کلاس مسئول پردازش پرداخت‌ های با استفاده از کارت‌ های اعتباری است. این زیر کلاس از کلاس انتزاعی Payment ارث‌ بری می‌ کند و متدهای `()validatePayment` و `()processPayment` را به‌طور خاص برای پرداخت با کارت اعتباری پیاده‌ سازی می‌ کند.


ویژگی‌ ها:

`amount`: مبلغ پرداخت که از طریق سازنده دریافت می‌ شود

`currency`: واحد ارزی که برای پرداخت استفاده می‌ شود 

`customerInfo`: اطلاعات مشتری (مثلاً نام و ایمیل)

`paymentDetails`: جزئیات پرداخت

`config`:API تنظیمات برای اتصال به  پردازش کارت اعتباری


متد های اصلی:

`validatePayment()`: این متد بررسی می‌کند که آیا اطلاعات کارت اعتباری  معتبر است یا خیر

`processPayment()`: این متد پردازش پرداخت با کارت اعتباری را انجام می‌دهد


### معرفی زیرکلاس `DigitalWalletPayment`:

این کلاس مسئول پردازش پرداخت ها با استفاده از کیف پول دیجیتال می باشد. این کلاس مانند کلاس `CreditCardPayment` از کلاس `Payment` ارث بری می کند و متد های آن را `override` می کند.

فیلد های زیر در این کلاس استفاده می شوند:

`amount`: مبلغ مورد نظر برای پرداخت از طریق کیف پول

`currency`: واحد پول استفاده شده در پرداخت

`customerInfo`: اطلاعات پرداخت کننده

`paymentDetails`: جزئیات پرداخت از جمله شناسه کیف پول

`config`: پیکربندی مورد استفاده برای استفاده از درگاه پردازش کیف پول دیجیتال

متد های کلاس:

`validatePayment()`:

.

 از این متد برای مطمئن شدن از وجود شناسه کیف پول در `paymentDetails` استفاده می شود.

`processPayment()`: 

این متد پس از اتصال به API کیف پول دیجیتال، پرداخت را پردازش می کند.



### معرفی زیرکلاس `BankTransferPayment`:


این کلاس مسئول پردازش پرداخت ها به وسیله پرداخت بانکی می باشد. این کلاس مانند کلاس `CreditCardPayment` از کلاس `Payment` ارث بری می کند و متد های آن را `override` می کند.

فیلد های زیر در این کلاس استفاده می شوند:

`amount`: مبلغ مورد نظر برای پرداخت از طریق پرداخت بانکی

`currency`: واحد پول استفاده شده در پرداخت

`customerInfo`: اطلاعات پرداخت کننده

`paymentDetails`: جزئیات پرداخت از جمله شناسه کاربری شخص

`config`: پیکربندی مورد استفاده برای استفاده از درگاه پردازش پرداخت بانکی

متد های کلاس:

`validatePayment()`:

 از این متد برای مطمئن شدن از وجود شناسه کاربر در `paymentDetails` استفاده می شود.

`processPayment()`: 

این متد با تراکنش بانکی پرداخت را انجام می دهد.



# فاز ۳: وراثت و چندریختی با رابط `PaymentGateway`

در فاز سوم پروژه، یک رابط به نام `PaymentGateway` برای جداسازی یکپارچه‌ سازی درگاه‌ های پرداخت مختلف از منطق اصلی پرداخت را پیاده سازی کردیم. این رابط به ما این امکان را می‌ دهد که منطق پردازش پرداخت را از جزئیات پیاده‌ سازی درگاه‌ های پرداخت جدا کنیم و امکان گسترش سیستم را با اضافه کردن درگاه‌ های جدید فراهم کنیم.

## ۱. طراحی رابط PaymentGateway:

یک رابط به نام `PaymentGateway` تعریف شد که متد های لازم برای پردازش پرداخت، بازپرداخت و دریافت وضعیت تراکنش‌ ها را در خود دارد.

`processPayment`: برای پردازش یک تراکنش پرداخت

`refundPayment`: برای پردازش بازپرداخت تراکنش‌ها

`getTransactionStatus`: برای دریافت وضعیت یک تراکنش


##  ۲. پیاده‌ سازی درگاه‌ های مشخص:

در این مرحله، درگاه‌ های پرداخت مختلف مانند `StripeGateway` و `PayPalGateway` که از رابط `PaymentGateway` پیروی می‌ کنند، طراحی و پیاده‌ سازی شدند.
دو درگاه پرداخت  هر کدام رابط `PaymentGateway` را پیاده‌ سازی کرده‌ اند و متد های آن را به‌ طور خاص برای درگاه خود پیاده‌ سازی کرده‌ اند. هر یک از این کلاس‌ ها به‌ طور مستقل از یکدیگر به یکپارچه‌ سازی APIهای خود می‌ پردازند.

### پیاده‌سازی PayPalGateway:

این کلاس به‌ طور خاص برای پردازش پرداخت‌ ها، بازپرداخت‌ ها و دریافت وضعیت تراکنش‌ ها در سیستم‌ های مرتبط با `PayPal` طراحی شده است.
کلاس `PayPalGateway` به‌ طور مستقیم از رابط `PaymentGateway` پیروی می‌کند و متدهای اصلی آن را پیاده‌ سازی می‌کند. این کلاس به‌طور خاص به‌ منظور پردازش پرداخت‌ ها و ارتباط با API های مختلف PayPal از جمله پردازش پرداخت، بازپرداخت و دریافت وضعیت تراکنش‌ ها پیاده‌ سازی شده است.

متدهای پیاده‌سازی‌ شده:
متد `processPayment`: این متد برای پردازش پرداخت‌ ها از سوی کاربر استفاده می‌ شود. در این متد، ابتدا به endpoint پردازش پرداخت PayPal متصل می‌شود و سپس اطلاعات پرداخت مانند نوع پرداخت و شناسه تراکنش تولید می‌شود. شناسه تراکنش بر اساس زمان فعلی تولید می‌شود تا از یکتایی آن اطمینان حاصل شود.

ورودی‌ها:

`amount`: مبلغ پرداختی

`currency`: واحد ارزی

`customerInfo`: اطلاعات مشتری

`paymentDetails`:  ها endpoint جزئیات پرداخت از جمله  نوع پرداخت

خروجی:

شناسه تراکنش که به‌ صورت یک رشته بر اساس نوع پرداخت و زمان فعلی ساخته می‌ شود.

### پیاده‌سازی `StripeGateway`:

این کلاس به‌ طور خاص برای پردازش پرداخت‌ ها، بازپرداخت‌ ها و دریافت وضعیت تراکنش‌ ها در سیستم‌ های مرتبط با `Stripe` طراحی شده است.
کلاس `StripeGateway` نیز مانند `PayPalGateway`، به‌ طور مستقیم از رابط `PaymentGateway` پیروی کرده و متدهای اصلی آن شامل `processPayment`، `refundPayment` و `getTransactionStatus` را پیاده‌ سازی می‌کند.
هدف این کلاس، شبیه‌ سازی رفتار درگاه پرداخت `Stripe` و فراهم کردن امکان پردازش انعطاف‌ پذیر پرداخت‌ ها با استفاده از پیکر بندی‌ های قابل تغییر است.

متدهای پیاده‌سازی‌ شده:
متد `processPayment`: این متد وظیفه‌ی پردازش پرداخت‌ ها از سمت کاربر را برعهده دارد. در ابتدا به `endpoint` پردازش پرداخت `Stripe` متصل می‌شود (که از Map پیکربندی استخراج می‌شود) و سپس اطلاعات پرداخت را دریافت کرده و شناسه تراکنش (`transactionId`) تولید می‌کند.
شناسه تراکنش بر اساس نوع پرداخت و زمان جاری ساخته می‌شود تا از یکتایی آن اطمینان حاصل شود.


ورودی‌ها:

`amount`: مبلغ پرداخت

`currency`: نوع ارز

`customerInfo`: اطلاعات مشتری

`paymentDetails`: `endpoint`جزئیات پرداخت شامل نوع پرداخت و 

خروجی:

یک رشته حاوی شناسه تراکنش (`transactionId`) که نشان‌ دهنده پرداخت موفق است.



##   ۳. پیاده‌سازی چندریختی (Polymorphism) در سیستم پرداخت:

چندریختی یکی از اصول بنیادی در برنامه‌نویسی شی‌ گرا به شمار می‌آید که امکان استفاده از یک رابط واحد برای رفتار های مختلف در کلاس‌های متفاوت را فراهم می‌کند. در این سیستم پرداخت ما، چندریختی به‌ گونه‌ای طراحی شده که اجزای مختلف بتوانند به صورت مستقل توسعه یافته و در زمان اجرا با یکدیگر جایگزین شوند، بدون نیاز به تغییر در منطق مرکزی برنامه.
کلاس `PaymentProcessor` نقش میانی بین سیستم و درگاه‌های پرداخت را ایفا می‌کند. این کلاس قادر است با استفاده از متد `setGateway` درگاه پرداخت فعال را در زمان اجرا تغییر دهد و متد `processPayment` را روی شیء پرداختی اعمال کند. این قابلیت یکی از جلوه‌های مهم چندریختی است، چرا که امکان پردازش انواع مختلف پرداخت از طریق درگاه‌های مختلف، بدون نیاز به بازنویسی منطق سیستم، فراهم می‌شود.

کلاس `PaymentClient` به عنوان نقطه آغاز اجرای برنامه، پیاده‌سازی شده است. در این کلاس، دو درگاه `PayPal` و `Stripe` مقداردهی اولیه می‌شوند و چند نمونه از پرداخت‌ها با استفاده از اطلاعات مشتری و جزئیات پرداخت ایجاد می‌ گردد. سپس هر پرداخت با استفاده از هر دو درگاه اجرا می‌شود. این ساختار به‌روشنی نشان می‌دهد که چگونه با استفاده از چندریختی می‌توان یک شیء پرداخت را به شیوه‌ای یکسان از طریق درگاه‌های متفاوت پردازش نمود. همچنین با استفاده از شرط `validatePayment`، از صحت اطلاعات پرداخت اطمینان حاصل می‌شود و سپس عملیات انجام می‌گیرد. اجرای این کلاس در محیط کنسول، صحت عملکرد چندریختی را به‌صورت مستقیم نمایش می‌دهد.

در ادامه، کلاس `PolymorphismDemo` به عنوان یک رابط تعاملی پیاده‌سازی شده است که امکان انتخاب درگاه توسط کاربر را فراهم می‌سازد. پس از انتخاب درگاه، سیستم تمام پرداخت‌ ها را از طریق آن درگاه پردازش می‌کند. این قابلیت، مصداق بارز چندریختی در زمان اجرا است؛ جایی که رفتار شیء بسته به نوع پیاد ه‌سازی مورد استفاده در زمان اجرا تغییر می‌کند، بدون آن‌که ساختار کلی برنامه تغییری کند.

در نهایت، اجرای برنامه و تغییر درگاه‌ ها در زمان اجرا بدون نیاز به بازنویسی یا تداخل در سایر بخش‌ های سیستم، مصداق بارزی از چندریختی در طراحی شی‌ گراست. اسکرین‌ شات‌ های اجرای برنامه نیز نشان می‌دهند که سیستم به‌درستی می‌تواند انواع پرداخت را از طریق درگاه‌ های مختلف پردازش کرده و خروجی‌ هایی سازگار تولید کند.


![p1](https://github.com/user-attachments/assets/2d3a0b94-5fd9-4437-a730-70e0c82ecb00)




# فاز ۴: یکپارچه‌ سازی و بازآرایی پیشرفته

## ۱. پیاده سازی dependency injection:

برای تزریق کلاس های 
gateway
ابتدا 
interface PaymentGateway
را به عنوان تایپ های ورودی در
PaymentProcessor
و کلاس های 
payment
قرار دادیم که در اولی به عنوان ورودی 
ctor
و 
در دومی به عنوان ورودی متد
processPayment
گذاشتیم که این مورد باعث می شود که این کلاس ها مستقل از تایپ 
gateway
شوند و بتوان از بیرون کلاس های 
gateway
را به این ها تزریق کرد.

سپس برای آن که در مرحله ساخت نیز دچار استفاده از 
switch case
نشویم که خیلی با اصل 
ocp 
همراه نیست آمدیم و از کلاس های 
GatewayGetter
استفاده کردیم که این ها می آیند و این 
gateway
ها را برای ما میسازند. سپس این 
getter
ها را در 
GatewatProvider
تعریف کردیم که هر کدام با استفاده از کلید مخصوص خود در یک 
Map
قابل دسترسی باشند و در کلاس 
PaymentClient
صرفا با استفاده از کلید مربوط آن ها را دریافت کردیم و صرفا به 
PaymentProcessor
پاس دادیم و به این طریق تزریق نهایی انجام گرفت.

همچنان برای
hard code
نکردن 
api 
ها آمدیم و در همان کلاس های
getter
این اطلاعات را از متغیر های محیطی خواندیم. البته که مقادیر پیش فرضی نیز برایشان گذاشتیم تا اجرای برنامه در حالت تستی مختل نشود.


##  ۲. ایزوله‌سازی کد:
برای افزایش خوانایی، قابلیت نگهداری، تست‌ پذیری و توسعه‌ پذیری کد، ساختار پروژه به صورت ماژولار بازطراحی شده و منطق‌های کلیدی به صورت ایزوله پیاده‌ سازی شده‌ اند. اقدامات زیر در راستای این هدف انجام گرفته است:

### 1.پردازش پرداخت و جداسازی منطق‌ها (`Separation of Concerns`)

پروژه به صورت واضح به ماژول‌های مجزا تفکیک شده است:

ماژول `Payment/`: شامل کلاس‌های مرتبط با انواع روش‌های پرداخت (مثل `CreditCardPayment`, `BankTransferPayment`, `DigitalWalletPayment`) و همچنین کلاس‌های کنترل‌ کننده مثل `PaymentProcessor` و `PaymentClient`.

ماژول `Gateway/`: شامل دو بخش `GatewayClasses` و `GatewayProviders` است که پیاده‌سازی و فراخوانی درگاه‌ های مختلف مثل `Stripe` و `PayPal` را مدیریت می‌کنند.


### 2.یکپارچه‌ سازی درگاه‌ ها و طراحی مبتنی بر `Interface`

کلاس‌هایی مانند `PaymentGateway.java` و `GatewayProvider.java` به عنوان اینترفیس‌ های اصلی برای پیاده‌ سازی درگاه‌ ها و فراهم‌کننده‌های آن‌ها تعریف شده‌اند. این طراحی امکان استفاده از پیاده‌ سازی‌های مختلف بدون تغییر در منطق بالا‌دستی را فراهم می‌کند.

### 3.مدیریت پیکربندی و یکپارچه‌سازی از طریق Getterهای ماژولار

کلاس‌هایی مثل `StripeGatewayGetter` و `PayPalGatewayGetter` مسئول فراهم کردن نمونه‌های درگاه‌ ها به صورت مستقل هستند. این ساختار وابستگی مستقیم به پیاده‌ سازی خاص را حذف کرده و انعطاف‌ پذیری را افزایش می‌دهد.

